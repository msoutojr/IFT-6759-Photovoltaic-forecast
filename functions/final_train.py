# -*- coding: utf-8 -*-
"""final_train_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s3m28wDNcAZrkn-8H2FyMoxeBEtzHGZB
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from torch import nn
from torchvision import transforms
from torch.utils.data import Dataset, DataLoader, TensorDataset, random_split
import Sunsets

"""**New code 0804**"""

images_train = np.load('/content/drive/MyDrive/val_train_split/images_trainval.npy')
images_val = np.load('/content/drive/MyDrive/val_train_split/images_val.npy')

labels_train = np.load('pv_log_trainval.npy')
labels_val = np.load('pv_log_val.npy')

images_test = np.load('images_test.npy')
labels_test = np.load('pv_log_test.npy')

weather_train = pd.read_csv('trainval_phys_3calsses')["weather"]
weather_val = pd.read_csv('val_phys_3calsses')["weather"]

plt.hist(weather_val)
plt.show()

weather_test = pd.read_csv('test_phys_3calsses', header=None).iloc[:, 0]

images_train_sunny = images_train[(weather_train == 'sunny').to_numpy()]
images_train_cloudy = images_train[(weather_train == 'cloudy').to_numpy()]
images_train_overcast = images_train[(weather_train == 'overcast').to_numpy()]

labels_train_sunny = labels_train[(weather_train == 'sunny').to_numpy()]
labels_train_cloudy = labels_train[(weather_train == 'cloudy').to_numpy()]
labels_train_overcast = labels_train[(weather_train == 'overcast').to_numpy()]

images_val_sunny = images_val[(weather_val == 'sunny').to_numpy()]
images_val_cloudy = images_val[(weather_val == 'cloudy').to_numpy()]
images_val_overcast = images_val[(weather_val == 'overcast').to_numpy()]

labels_val_sunny = labels_val[(weather_val == 'sunny').to_numpy()]
labels_val_cloudy = labels_val[(weather_val == 'cloudy').to_numpy()]
labels_val_overcast = labels_val[(weather_val == 'overcast').to_numpy()]

images_test_sunny = images_test[(weather_test == 'sunny').to_numpy()]
images_test_cloudy = images_test[(weather_test == 'cloudy').to_numpy()]
images_test_overcast = images_test[(weather_test == 'overcast').to_numpy()]

labels_test_sunny = labels_test[(weather_test == 'sunny').to_numpy()]
labels_test_cloudy = labels_test[(weather_test == 'cloudy').to_numpy()]
labels_test_overcast = labels_test[(weather_test == 'overcast').to_numpy()]


class WeatherDataset(Dataset):
    def __init__(self, images, labels):
        super(Dataset, self).__init__()
        self.images = images
        self.labels = labels
        self.transform = transforms.Compose([transforms.ToTensor()])

    def __getitem__(self, index):
        item = {
            'images': self.transform(self.images[index]), 
            'labels': self.labels[index]
        }
        return item

    def __len__(self):
        return len(self.images)


train_dataset_sunny = WeatherDataset(images=images_train_sunny, labels=labels_train_sunny)
train_dataset_cloudy = WeatherDataset(images=images_train_cloudy, labels=labels_train_cloudy)
train_dataset_overcast = WeatherDataset(images=images_train_overcast, labels=labels_train_overcast)

val_dataset_sunny = WeatherDataset(images=images_val_sunny, labels=labels_val_sunny)
val_dataset_cloudy = WeatherDataset(images=images_val_cloudy, labels=labels_val_cloudy)
val_dataset_overcast = WeatherDataset(images=images_val_overcast, labels=labels_val_overcast)

test_dataset_sunny = WeatherDataset(images=images_test_sunny, labels=labels_test_sunny)
test_dataset_cloudy = WeatherDataset(images=images_test_cloudy, labels=labels_test_cloudy)
test_dataset_overcast = WeatherDataset(images=images_test_overcast, labels=labels_test_overcast)

train_dataloader_sunny = DataLoader(
    train_dataset_sunny, 
    batch_size=256, 
    shuffle=True
)

train_dataloader_cloudy = DataLoader(
    train_dataset_cloudy, 
    batch_size=256, 
    shuffle=True
)

train_dataloader_overcast = DataLoader(
    train_dataset_overcast, 
    batch_size=256, 
    shuffle=True
)

val_dataloader_sunny = DataLoader(
    val_dataset_sunny,
    batch_size=256, 
    shuffle=True
)

val_dataloader_cloudy = DataLoader(
    val_dataset_cloudy,
    batch_size=256, 
    shuffle=True
)

val_dataloader_overcast = DataLoader(
    val_dataset_overcast,
    batch_size=256, 
    shuffle=True
)

test_dataloader_sunny = DataLoader(
    test_dataset_sunny,
    batch_size=1, 
    shuffle=False
)

test_dataloader_cloudy = DataLoader(
    test_dataset_cloudy,
    batch_size=1, 
    shuffle=False
)

test_dataloader_overcast = DataLoader(
    test_dataset_overcast,
    batch_size=1, 
    shuffle=False
)

models = {
    'sunny': Sunsets.SunsetSunny(), 
    'cloudy': Sunsets.SunsetCloudy(),
    'overcast': Sunsets.SunsetOvercast()
}

data = { 
    'train': {
        'sunny': train_dataloader_sunny,
        'cloudy': train_dataloader_cloudy, 
        'overcast': train_dataloader_overcast
    },
    'val': {
        'sunny': val_dataloader_sunny, 
        'cloudy': val_dataloader_cloudy, 
        'overcast': val_dataloader_overcast
    },
    'test': {
        'sunny': test_dataloader_sunny, 
        'cloudy': test_dataloader_cloudy,
        'overcast': test_dataloader_overcast
    }
}


class Trainer:
    def __init__(
        self,
        data, 
        models
    ):
        self.data = data
        self.models = models
        self.weathers = list(models.keys())
        self.train_loss = {
            k: [] for k in self.weathers
        } 
        self.val_loss = {
            k: [] for k in self.weathers
        }
        self.test_loss = {
            k: [] for k in self.weathers
        }
        self.device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
        self.loss_mse = nn.MSELoss().to(self.device)
        self.flatten = nn.Flatten(0)
    
    def loss_fn(self, predictions, targets):
        return torch.sqrt(self.loss_mse(predictions, targets))

    def trainer(
        self,
        epochs=4, 
        lr=3e-6#,
        # weight_decay = 1e-5
    ):

        loss_train = []
        loss_val = []

        for weather in self.weathers:
            print("-----------\n")
            loss_train.clear()
            loss_val.clear()

            model = self.models[weather].to(self.device)
            optimizer = torch.optim.Adam(model.parameters(), lr=lr)
            train_dataloader = self.data['train'][weather]
            val_dataloader = self.data['val'][weather]
            
            for epoch in range(epochs):
                print(f"Epoch: {epoch+1}", end=f' for weather: {weather} -> ')
                model.train()
                for batch in train_dataloader:
                    images = batch['images'].to(self.device).type(torch.float32)
                    labels = batch['labels'].to(self.device).type(torch.float32)

                    output = model(images)
                    output = self.flatten(output)

                    optimizer.zero_grad()
                    loss = self.loss_fn(output, labels)
                    
                    # loss_train.append(torch.sqrt(loss).item())
                    loss_train.append(loss.item())


                    loss.backward()
                    optimizer.step()

                model.eval()
                for batch in val_dataloader:
                    images = batch['images'].to(self.device)
                    labels = batch['labels'].to(self.device)

                    output = model(images)
                    output = self.flatten(output)

                    loss = self.loss_fn(output, labels)
                    
                    loss_val.append(loss.item())

                self.loss_train_avg = sum(loss_train)/len(loss_train)
                self.loss_val_avg = sum(loss_val)/len(loss_val)

                self.train_loss[weather].append(self.loss_train_avg)
                self.val_loss[weather].append(self.loss_val_avg)

                print(
                    f"Train Loss: {self.loss_train_avg}. Validation Loss: {self.loss_val_avg}"
                )
            torch.save(model.state_dict(), f'{weather}_model.pth')
    
    def test(self, model_path):

        final_losses = {k: {'count': 0, 'loss': 0} for k in models.keys()}
        total_samples = 0

        for weather in self.weathers:
            model = models[weather].to(self.device)
            state_dict = torch.load(f"{model_path}/{weather}_model.pth")
            model.load_state_dict(state_dict)

            test_loader = self.data['test'][weather]

            len_test_loader = len(test_loader)
            total_samples += len_test_loader

            final_losses[weather]['count'] = len_test_loader

            model.eval()
            output_1 = []
            labels_1 = []
            for batch in test_loader:
                images = batch['images'].to(self.device)
                labels = batch['labels'].to(self.device)

                output = model(images)
                output = self.flatten(output)
                output_1.append(output.item())
                labels_1.append(labels.item())

            array1 = np.array(output_1)
            array2 = np.array(labels_1)

            difference_array = np.subtract(array1, array2)
            squared_array = np.square(difference_array)
            mse = squared_array.mean()

            test_loss = np.sqrt(mse)
            final_losses[weather]['loss'] = test_loss
            
            print(f"Test Loss for {weather}: {test_loss}")

        final_losses_weighted = {
            k: {
                'weight': final_losses[k]['count']/total_samples,
                'loss': final_losses[k]['loss']
            }
            for k in self.weathers
        }

        final_loss = 0
        final_loss = sum(
            [
             (final_losses_weighted[weather]['weight']) * (final_losses_weighted[weather]['loss']**2)
                  for weather in self.weathers
            ]
        )

        final_loss = np.sqrt(final_loss)
        print(f"\nFinal Weighted Loss: {final_loss}")

    def plot(self):
        for weather in self.weathers:
            epochs = list(range(len(self.train_loss[weather])))

            self.__plot_helper(
                epochs=epochs, 
                loss_train=self.train_loss[weather],
                loss_val=self.val_loss[weather],
                title=f"Train and Validation RMSE Losses for {weather}"
            )

    @staticmethod
    def __plot_helper(epochs, loss_train, loss_val, title):
        plt.plot(epochs, loss_train, label='Train Loss')
        plt.plot(epochs, loss_val, label='Validation Loss')
        plt.xlabel('Epochs')
        plt.ylabel('RMSE Loss')
        plt.title(title)
        plt.legend()
        plt.show()
        plt.clf()
        return


if __name__ == "__main__":
    tr = Trainer(data=data, models=models)
    tr.trainer(epochs=40)
    tr.plot()
    tr.test("/content/")
